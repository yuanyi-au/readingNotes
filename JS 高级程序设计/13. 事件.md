事件：文档或浏览器窗口中发生的一些特定的交互瞬间。

# 事件流

事件流描述的是从页面中接收事件的顺序

## 事件冒泡 event bubbling

事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（document）

## 事件捕获 event capturing

由不太具体的节点先接受事件，最具体的节点最后接收到事件。

事件捕获的用意在于在事件到达预定目标之前捕获它。

## DOM 事件流

“DOM2 级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

# 事件处理程序

事件就是用户或浏览器自身执行的某种动作，为响应某个事件的函数就叫做事件处理程序（或事件监听器）。事件处理程序的名字以 "on" 开头，例如 onclick。

## HTML 事件处理程序
缺点：
- 存在时差问题，用户可能会在事件处理程序解析之前就触发相应事件，会抛出错误
- 事件处理程序的作用域链在不同浏览器中会导致不同结果
- HTML 与 JS 紧密耦合

## DOM0 级事件处理程序

通过 JS 指定事件处理程序的传统方式是将函数赋值给一个事件处理程序属性。

DOM0 级方法指定的事件处理程序被认为是元素的方法，因此事件处理程序是在元素的作用域中运行。可以通过 this 访问元素的任何属性和方法。

`btn.onclick = null; // 删除事件处理程序`

## DOM2 级事件处理程序

### addEventListener()

接受三个参数：要处理的事件名、作为事件处理程序的函数、布尔值（ true 表示在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序）。

大多数情况下都是将事件处理程序添加到事件流的冒泡阶段，可以最大程度兼容各种浏览器。

### removeEventListener()：

通过 addEventListener() 添加的事件处理程序只能通过 removeEventListener() 移除，两个方法传参相同。匿名函数无法移除。

## IE 事件处理程序

实现了与 DOM 中类似的两个方法：attachEvent() 和 detachEvent()

与 DOM0 级方法的主要区别是事件处理程序的作用域，IE 事件处理程序会在全局作用域中运行。

## 跨浏览器的事件处理程序

要保证处理事件的代码能在大多数浏览器下一致地运行，只需要关注冒泡阶段

### addHandler()
- 职责：视情况分别使用 DOM0 级方法、DOM2 级方法、IE 方法来添加事件
- 接受三个参数：要操作的元素、事件名称、事件处理程序函数
- 属于 EventUtil 对象

# 事件对象

在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息

## DOM 中的事件对象

stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡

eventPhase 属性用于确定事件当前处于事件流中的哪个阶段（捕获阶段为1，处于目标对象上时为2，冒泡阶段为3）

## IE 中的事件对象

在使用 DOM0 级方法添加事件处理程序时，event 对象作为 window 对象的一个属性存在

# 事件类型

DOM3 级事件规定了以下几类事件：

## UI 事件

不一定与用户操作有关的事件，包括 load, unload, abort, error, select, resize, scroll

unload 事件最多的用法是清除引用，以避免内存泄漏。

resize 事件在窗口最大化或最小化时也会被触发。

## 焦点事件

blur/focus

## 鼠标与滚轮事件

9个鼠标事件：
- click：单击
- dbclick：双击
- mousedown：按下任意鼠标按钮
- mouseenter：鼠标光标从元素外部首次移动到元素范围内时触发，不冒泡，光标移动到后代元素上不会触发
- mouseleave：鼠标光标从元素上方移动到元素范围外时触发，不冒泡，光标移动到后代元素上不会触发
- mousemove：鼠标指针在元素内部移动时重复触发
- mouseout：鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发
- mouseover：鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界内时触发
- mouseup：释放鼠标按钮时触发

只有在同一个元素上相继触发 mousedown 和 mouseup 事件，才会触发 click 事件，其中一个事件被取消就不会触发 click 事件

- 客户区坐标位置：clientX 和 clientY
- 页面坐标位置：pageX 和 pageY
- 屏幕坐标位置：screenX 和 screenY

## 文本事件

textInput 事件：在文本插入文本框前触发

## 键盘事件
- keydown：按下键盘上任意键触发
- keypress：按下键盘上的字符键时触发
- keyup：释放键盘上的键时触发

如果用户按下一个字符键，则触发事件顺序为：keydown-keypress-keyup

## 复合事件 composition event

DOM3 中新添加的事件，用于处理 IME (Input Method Editor 输入法编辑器) 的输入序列，让用户输入在物理键盘上找不到的字符。

## 变动事件 mutation

DOM2 级的变动事件能在 DOM 中的某一部分发生变化时给出提示

## HTML5 事件
- contextmenu 事件：显示自定义的上下文菜单。
- beforeunload 事件：在卸载页面前触发。
- DOMContentLoaded 事件：在形成完整的 DOM 树后就会触发，不理会 CSS 文件、JS 文件、图片等其他资源是否下载完毕。处理该事件的程序需要添加到 document 或 window 上。
- readystatechange 事件：提供与加载状态有关的信息。与 load 一起使用时无法预测两个事件触发的先后顺序。
- pageshow 和 pagehide 事件
- hashchange 事件：URL 参数列表变化时触发

# 内存和性能

因为每个函数都是对象，都要占用内存，对象越多性能越差。而且必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间

## 事件委托

对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术。

## 移除事件处理程序

如果带有事件处理程序的元素被 innerHTML 删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。

最好的做法是在页面卸载之前先通过 unload 事件处理程序移除所有事件处理程序。

# 模拟事件

可以用 JS 在浏览器中模拟事件，这些事件就和浏览器自己创建的事件一样，能冒泡，能执行指定的事件处理程序。