# 基本类型和引用类型的值
## 动态的属性
- 基本类型的值无法添加属性，虽然为其添加属性不会报错，访问时只会显示 undefined
- 引用类型的值可以添加属性与方法，也可以修改删除已保存的属性与方法
## 复制变量值
- 基本类型的值在复制时，复制的是值本身，新旧变量彼此独立不会相互影响
- 引用类型的值在复制时，复制的是一个指针，指向存储在堆中的一个对象，实际上新旧变量引用的是同一个对象，因此当这个对象改变时，新旧变量都会跟着改变
## 传递参数
ECMAScript 中所有函数的参数都是按值传递的，也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。
一个例子：
```
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}

var person = new Object();
setName(person);
alert(person.name); // "Nicholas"
```
这个例子中，在 setName() 函数内重新定义了一个对象并为其添加属性，在把 person 传递给 setName() 后，其 name 属性被设置成 "Nicholas"。又将一个新对象赋给变量obj，同时将其 name 属性设置为 "Greg"。如果 person 是按引用传递的话，person.name 应该会返回 "Greg"，返回 "Nicholas" 说明即使修改了参数的值，原始的引用依然未变。实际上，在函数内部重写 obj 时，这个变量引用的是一个局部对象，这个局部对象会在函数执行完毕后立刻销毁。
## 检测类型
- 检测基本数据类型最好的方法是 typeof() （第三章有讲过）
- 检测引用数据类型最好的方法是 instanceof()
   `result = variable instanceof constructor`
   例如：
   ```
   alert(person instanceof Object); // 变量 person 是 Object 类型吗
   alert(color instanceof Array); // 变量 color 是 Array 类型吗
   ```
   所有引用类型的值都是 Object 的实例，所以检测是否为 Object 都会返回 true

关于正则表达式：在 IE 和Firefox 中对正则表达式应用 typeof() 会返回 "object"，在 Safari 5 及之前版本和 Chrome 7 及之前版本会返回 "function"

# 执行环境及作用域
执行环境 (execution context) 定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有与之关联的变量对象 (variable object)。

全局执行环境是最外围的执行环境，对于 Web 浏览器来说，全局执行环境就是 window 对象。

某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局执行环境直到应用程序退出，例如关闭网页或浏览器，才会被销毁。

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链 (scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行代码所在环境的变量对象。如果这个环境是函数，则将其活动对象 (activation object) 作为变量对象。活动对象在最开始只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境，就这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域中的最后一个对象。

## 延长作用域链
在作用域链前端增加一个变量对象，延长作用域链的两种方法：
- try-catch 语句的 catch 块，会创建一个新的变量对象，包含被抛出的错误对象的声明
- with 语句，将指定对象添加到作用域链中

## 没有块级作用域
注意：在 ES6 中已经有块级作用域了！//TODO:

在 JS 中，if 语句和 for 语句声明的变量会被添加到当前执行环境中，要等到循环外部执行环境被销毁时才会被一并销毁。例如：
```
if (true) {
    var color = "blue";
}
alert(color); // "blue"
```
### 声明变量
使用 var 声明的变量会自动被添加到最接近的环境中，如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境（请不要用这样的方法声明全局变量！）。//TODO:

### 查询标识符
从作用域链前端开始，向上逐级查询与给定名字匹配的标识符

# 垃圾收集
JS 具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。

原理：找出不再使用的变量，释放其占用的内存，按照固定的时间间隔周期性执行这一操作。
## 标记清除 mark-and-sweep
垃圾收集器在运行的时候会给储存在内存中的所有变量都加上标记，然后会去掉环境中的变量以及被环境中的变量引用的变量的标记，在此之后，再被标记的变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了。
## 引用计数 reference counting
当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反地，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，就说明没有办法在访问这个值了，就可以将其占用的内存空间收回来。

这个方法存在循环引用的问题，会发生内存泄漏。

IE9 把 BOM 和 DOM 对象都转换成了真正的 JS 对象，避免了两种垃圾收集算法并存导致的问题，消除了常见的内存泄漏现象。
## 管理内存
出于安全方面的考虑，分配给 Web 浏览器的可用内存数量通常要比分配给桌面程序的少，目的是防止运行 JS 的网页因为耗尽系统内存而导致系统崩溃。

优化内存的最好方式就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好将其设置为 null 来释放引用。这个方法叫做解除引用(dereferencing)。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动被解除引用。

解除一个值的引用并不意味着自动回收该值所占用的内存，只是为了让这个值脱离执行环境，以便垃圾收集器下次运行时将其回收。